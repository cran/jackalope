<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Intro to jackalope</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Intro to jackalope</h1>



<p>This document provides brief examples of how <code>jackalope</code>
can be used to generate sequencing data that can inform some common
sampling decisions for HTS studies.</p>
<div id="generating-reference-genome" class="section level2">
<h2>Generating reference genome</h2>
<p>Here, I’ll show how to generate a reference genome based on an
existing assembly or via simulated DNA sequences.</p>
<p>To show how an existing assembly is read in <code>jackalope</code>,
the code below processes the assembly for <em>Drosophila
melanogaster</em> (version 6.27) downloaded from
<code>https://flybase.org</code>. It reads the compressed FASTA file,
filters out scaffolds by using a size threshold, removes the Y
chromosome (to avoid having both an X and Y in the same haplotype), and
merges the left and right arms of chromosomes 2 and 3. It lastly sets
the names of chromosomes 2 and 3 to be <code>&quot;2&quot;</code> and
<code>&quot;3&quot;</code>, respectively.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>ref <span class="ot">&lt;-</span> <span class="fu">read_fasta</span>(<span class="st">&quot;dmel-6.27.fasta.gz&quot;</span>, <span class="at">cut_names =</span> <span class="cn">TRUE</span>)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>ref<span class="sc">$</span><span class="fu">filter_chroms</span>(<span class="fl">1e6</span>, <span class="at">method =</span> <span class="st">&quot;size&quot;</span>)</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>ref<span class="sc">$</span><span class="fu">rm_chroms</span>(<span class="st">&quot;Y&quot;</span>)</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>ref<span class="sc">$</span><span class="fu">merge_chroms</span>(<span class="fu">c</span>(<span class="st">&quot;2L&quot;</span>, <span class="st">&quot;2R&quot;</span>))</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>ref<span class="sc">$</span><span class="fu">merge_chroms</span>(<span class="fu">c</span>(<span class="st">&quot;3L&quot;</span>, <span class="st">&quot;3R&quot;</span>))</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>names <span class="ot">&lt;-</span> ref<span class="sc">$</span><span class="fu">chrom_names</span>()</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>names[<span class="fu">grepl</span>(<span class="st">&quot;^2&quot;</span>, names)] <span class="ot">&lt;-</span> <span class="st">&quot;2&quot;</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>names[<span class="fu">grepl</span>(<span class="st">&quot;^3&quot;</span>, names)] <span class="ot">&lt;-</span> <span class="st">&quot;3&quot;</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>ref<span class="sc">$</span><span class="fu">set_names</span>(names)</span></code></pre></div>
<p>For the rest of the document, I will use a simulated genome for
simplicity (and so that I don’t have to store the <em>D.
melanogaster</em> genome inside this package). Here is how I simulated a
genome of size <span class="math inline">\(\sim 1\)</span> kb split
among 4 chromosomes, with the same names as the chromosomes in the
<em>D. melanogaster</em> genome:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>ref <span class="ot">&lt;-</span> <span class="fu">create_genome</span>(<span class="at">n_chroms =</span> <span class="dv">4</span>,</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>                     <span class="at">len_mean =</span> <span class="fl">1e3</span> <span class="sc">/</span> <span class="dv">4</span>,</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>                     <span class="at">len_sd =</span> <span class="dv">10</span>)</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>ref<span class="sc">$</span><span class="fu">set_names</span>(<span class="fu">c</span>(<span class="dv">2</span><span class="sc">:</span><span class="dv">4</span>, <span class="st">&quot;X&quot;</span>))</span></code></pre></div>
<p>This resulted in the following <code>ref_genome</code> object:</p>
<pre><code>#&gt; &lt; Set of 4 chromosomes &gt;
#&gt; # Total size: 961 bp
#&gt;   name                             chromosome                             length
#&gt; 2          TCTCACGGAAAACGGGAAGTTTTTGGCC...CAAGGCTTCGACGTAGAGCCGGTGGATT       232
#&gt; 3          GCTCCGGCAGCATCGGCTTCCGTGATCA...GGACTGCGGGGGTTCTAACGGGCGTCGG       245
#&gt; 4          GAATGCTCGCATGCGAACACTGAACGTT...GAATGCCAGTAAGCTCGAGCGTATAAGG       247
#&gt; X          CCCCATTTCAGCAACGAAGTCGATCGCA...GTTCAATCACGCGAAAAAAAACACGTCA       237</code></pre>
<p>For the examples below, we’ll pretend this is our <em>D.
melanogaster</em> genome.</p>
</div>
<div id="molecular-evolution-information" class="section level2">
<h2>Molecular evolution information</h2>
<p>To generate variant haplotypes based on our reference genome, we need
molecular evolution information (unless passing a Variant Call Format,
or VCF, file). For molecular-evolution information, I used the JC69
model for simplicity. Mutation rates were chosen from the
<code>evo_rates</code> object present inside <code>jackalope</code>,
which stores Table 1 from <a href="https://dx.doi.org/10.1534/g3.116.030890">Sung et al. (2016)</a>.
The substitution and indel rates were the values from
<code>evo_rates</code> specific to <em>D. melanogaster</em>. The
<code>mu</code> parameter to <code>sub_JC69</code> function was set to
<code>NULL</code> because the default behavior of all substitution-model
functions in <code>jackalope</code> is to scale rate matrices such that
branch lengths are in units of substitutions per site. In this case, I
don’t want to scale rate matrices because our branch lengths will be in
generations. <a href="https://doi.org/10.1093/nar/gkg745">Zhang and
Gerstein (2003)</a> found a 1 to 2.90 ratio of insertions to deletions,
and described relative rates of indels of various sizes using a
power-law relationship. To approximate the distributions they described,
relative rates were derived from a Lavalette distribution with <span class="math inline">\(L = 60\)</span> and <span class="math inline">\(a
= 1.60\)</span> for insertions and <span class="math inline">\(a =
1.51\)</span> for deletions. The <span class="math inline">\(\theta\)</span> parameter is the population-scaled
mutation rate, which we can get directly from <code>evo_rates</code> for
<em>D. melanogaster</em>. Lastly, <span class="math inline">\(N_0\)</span> is the effective population size for
<em>D. melanogaster</em>, which is used in a few instances below because
<code>scrm</code> outputs branch lengths in units of <span class="math inline">\(4 N_0\)</span> generations.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>sub_rate <span class="ot">&lt;-</span> evo_rates<span class="sc">$</span>subs[evo_rates<span class="sc">$</span>species <span class="sc">==</span> <span class="st">&quot;Drosophila melanogaster&quot;</span>]</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>indel_rate <span class="ot">&lt;-</span> evo_rates<span class="sc">$</span>indels[evo_rates<span class="sc">$</span>species <span class="sc">==</span> <span class="st">&quot;Drosophila melanogaster&quot;</span>]</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="co"># Because both are in units of 10^-10 events per site per generation:</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>sub_rate <span class="ot">&lt;-</span> sub_rate <span class="sc">*</span> <span class="fl">1e-10</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>indel_rate <span class="ot">&lt;-</span> indel_rate <span class="sc">*</span> <span class="fl">1e-10</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a>sub <span class="ot">&lt;-</span> <span class="fu">sub_JC69</span>(<span class="at">lambda =</span> sub_rate, <span class="at">mu =</span> <span class="cn">NULL</span>)</span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a>ins <span class="ot">&lt;-</span> <span class="fu">indels</span>(<span class="at">rate =</span> indel_rate, <span class="at">max_length =</span> <span class="dv">60</span>,<span class="at">a =</span> <span class="fl">1.60</span>)</span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a>del <span class="ot">&lt;-</span> <span class="fu">indels</span>(<span class="at">rate =</span> indel_rate, <span class="at">max_length =</span> <span class="dv">60</span>, <span class="at">a =</span> <span class="fl">1.51</span>)</span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a>theta <span class="ot">&lt;-</span> evo_rates[evo_rates<span class="sc">$</span>species <span class="sc">==</span> <span class="st">&quot;Drosophila melanogaster&quot;</span>,<span class="st">&quot;theta_s&quot;</span>]</span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a><span class="co"># Originally in units of 1e6 individuals</span></span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a>N0 <span class="ot">&lt;-</span> evo_rates[evo_rates<span class="sc">$</span>species <span class="sc">==</span> <span class="st">&quot;Drosophila melanogaster&quot;</span>, <span class="st">&quot;Ne&quot;</span>] <span class="sc">*</span> <span class="fl">1e6</span></span></code></pre></div>
<p>When generating any haplotypes below, these objects will be used
inside <code>create_haplotypes</code> to specify molecular evolution
information.</p>
</div>
<div id="assembling-a-genome" class="section level2">
<h2>Assembling a genome</h2>
<div id="based-on-a-reference" class="section level3">
<h3>Based on a reference</h3>
<p>The examples here produce FASTQ files from the known reference
assembly that could test strategies for how to assemble a similar genome
using HTS data.</p>
<p>The first strategy is to use only PacBio sequencing. The PacBio
Sequel system produces up to 500,000 reads per Single Molecule,
Real-Time (SMRT) cell, so you could run the following for two cells
(with the file <code>pacbio_R1.fq</code> as output):</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="fu">pacbio</span>(ref, <span class="at">out_prefix =</span> <span class="st">&quot;pacbio&quot;</span>, <span class="at">n_reads =</span> <span class="dv">2</span> <span class="sc">*</span> <span class="fl">500e3</span>)</span></code></pre></div>
<p>An alternative, hybrid strategy uses 1 SMRT cell of PacBio sequencing
and 1 lane (<span class="math inline">\(\sim 500\)</span> million reads)
of <span class="math inline">\(2 \times 100\)</span>bp Illumina
sequencing on the HiSeq 2500 system (the default Illumina system in
<code>jackalope</code>):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="fu">pacbio</span>(ref, <span class="at">out_prefix =</span> <span class="st">&quot;pacbio&quot;</span>, <span class="at">n_reads =</span> <span class="fl">500e3</span>)</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="fu">illumina</span>(ref, <span class="at">out_prefix =</span> <span class="st">&quot;illumina&quot;</span>, <span class="at">n_reads =</span> <span class="fl">500e6</span>, <span class="at">paired =</span> <span class="cn">TRUE</span>,</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>         <span class="at">read_length =</span> <span class="dv">100</span>)</span></code></pre></div>
<p>The last strategy combines 1 lane of <span class="math inline">\(2
\times 100\)</span>bp Illumina HiSeq 2500 sequencing with 1 flow cell of
<span class="math inline">\(2 \times 250\)</span>bp mate-pair sequencing
on an Illumina MiSeq v3. The mate-pair sequencing uses longer fragments
(defaults are mean of 400 and standard deviation of 100) to better cover
highly repetitive regions.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">illumina</span>(ref, <span class="at">out_prefix =</span> <span class="st">&quot;ill_pe&quot;</span>, <span class="at">n_reads =</span> <span class="fl">500e6</span>, <span class="at">paired =</span> <span class="cn">TRUE</span>,</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>         <span class="at">read_length =</span> <span class="dv">100</span>)</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="fu">illumina</span>(ref, <span class="at">out_prefix =</span> <span class="st">&quot;ill_mp&quot;</span>, <span class="at">seq_sys =</span> <span class="st">&quot;MSv3&quot;</span>,</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>         <span class="at">read_length =</span> <span class="dv">250</span>, <span class="at">n_reads =</span> <span class="fl">50e6</span>, <span class="at">matepair =</span> <span class="cn">TRUE</span>, </span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>         <span class="at">frag_mean =</span> <span class="dv">3000</span>, <span class="at">frag_sd =</span> <span class="dv">500</span>)</span></code></pre></div>
<p>These data could then be used to compare genome assembly performance
between the strategies above, or between programs within a given
strategy. Extensions of these tests include adjusting sequencing depth,
sequencing platform, and error rates.</p>
</div>
<div id="based-on-a-diploid-individual" class="section level3">
<h3>Based on a diploid individual</h3>
<p>For diploid species, scientists won’t be sampling a haploid
reference, and heterozygosity can be a real problem for the assembly
process. So below I’ll show you how to simulate a diploid individual and
create reads based on that. I’ll just show the hybrid assembly strategy,
but the others simply differ in the sequencing step as shown above.</p>
<p>First, we’ll simulate two haplotypes based on the <span class="math inline">\(\theta\)</span> (population-scaled mutation rate)
and the other molecular evolution information for <em>D.
melanogaster</em> we got from the <code>evo_rates</code> object earlier.
I’m also renaming the haplotypes.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>haps <span class="ot">&lt;-</span> <span class="fu">create_haplotypes</span>(ref, <span class="fu">haps_theta</span>(<span class="at">theta =</span> theta, <span class="at">n_haps =</span> <span class="dv">2</span>), </span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>                          sub, ins, del)</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>haps<span class="sc">$</span><span class="fu">set_names</span>(<span class="fu">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>))</span></code></pre></div>
<p>This results in the following <code>haplotypes</code> object:</p>
<pre><code>#&gt;                               &lt;&lt; haplotypes object &gt;&gt;
#&gt; # Haplotypes: 2
#&gt; # Mutations: 21
#&gt; 
#&gt;                           &lt;&lt; Reference genome info: &gt;&gt;
#&gt; &lt; Set of 4 chromosomes &gt;
#&gt; # Total size: 961 bp
#&gt;   name                             chromosome                             length
#&gt; 2          TCTCACGGAAAACGGGAAGTTTTTGGCC...CAAGGCTTCGACGTAGAGCCGGTGGATT       232
#&gt; 3          GCTCCGGCAGCATCGGCTTCCGTGATCA...GGACTGCGGGGGTTCTAACGGGCGTCGG       245
#&gt; 4          GAATGCTCGCATGCGAACACTGAACGTT...GAATGCCAGTAAGCTCGAGCGTATAAGG       247
#&gt; X          CCCCATTTCAGCAACGAAGTCGATCGCA...GTTCAATCACGCGAAAAAAAACACGTCA       237</code></pre>
<p>We generate 1 SMRT cell of PacBio sequencing and 1 lane of <span class="math inline">\(2 \times 100\)</span>bp Illumina sequencing on the
HiSeq 2500 system as before, except using the new <code>haps</code>
object instead of <code>ref</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="fu">pacbio</span>(haps, <span class="at">out_prefix =</span> <span class="st">&quot;pacbio&quot;</span>, <span class="at">n_reads =</span> <span class="fl">500e3</span>)</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a><span class="fu">illumina</span>(haps, <span class="at">out_prefix =</span> <span class="st">&quot;illumina&quot;</span>, <span class="at">n_reads =</span> <span class="fl">500e6</span>, <span class="at">paired =</span> <span class="cn">TRUE</span>,</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>         <span class="at">read_length =</span> <span class="dv">100</span>)</span></code></pre></div>
<p>If we want to save the information for these haplotypes, we can
output FASTA files (one per haplotype) or a VCF file:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="fu">write_fasta</span>(haps, <span class="st">&quot;haps&quot;</span>)</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a><span class="fu">write_vcf</span>(haps, <span class="st">&quot;haps&quot;</span>, <span class="at">sample_matrix =</span> <span class="fu">cbind</span>(<span class="dv">1</span>, <span class="dv">2</span>))</span></code></pre></div>
<p>This would result in the following files being generated:
<code>haps__A.fa</code>, <code>haps__B.fa</code>, and
<code>haps.vcf</code>. The <code>sample_matrix</code> argument to
<code>write_vcf</code> states that the first two (i.e., all) haplotypes
are from the first (and only) sample. These data could test different
assembly strategies, similar to the above section, except that, for
diploid organisms, it includes heterozygosity. Increasing the <span class="math inline">\(\theta\)</span> parameter will result in more
heterozygosity, which is an obvious extension of these tests.</p>
</div>
</div>
<div id="estimating-divergence-between-populations" class="section level2">
<h2>Estimating divergence between populations</h2>
<p>Here, I will demonstrate how to generate population-genomic data of a
type that might be used to estimate the divergence between two
populations. I first use the <code>scrm</code> package to conduct
coalescent simulations that will generate segregating sites for 10
variant haplotypes from the reference genome. Five of the haplotypes are
from one population, five from another. The symmetrical migration rate
is 100 individuals per generation. I used a recombination rate of 1 (the
expected number of recombinations on the locus per <span class="math inline">\(4 N_0\)</span> generations). I specify the
recombination rate and chromosome size for <code>scrm</code> using the
command <code>-r 1 C</code> for chromosome size <code>C</code>. I used
the population-scaled mutation rate for <em>D. melanogaster</em>, scaled
such that the mutation rate (<span class="math inline">\(\mu\)</span>)
is in units of mutations per <span class="math inline">\(4 N_0\)</span>
generations, where <span class="math inline">\(N_0\)</span> is the
population size. For <span class="math inline">\(N_0\)</span>, I’m using
the effective population size for <em>D. melanogaster</em>, per
<code>evo_rates</code>. The other code in the chunk below is to convert
the output to look like that from the <code>scrm</code> R package, which
can be easily processed by <code>jackalope</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="fu">library</span>(scrm)</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="co"># Function to run scrm for one chromosome and format output</span></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>one_chrom <span class="ot">&lt;-</span> <span class="cf">function</span>(.size) {</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>    ssites <span class="ot">&lt;-</span> <span class="fu">scrm</span>(<span class="fu">sprintf</span>(<span class="st">&quot;10 1 -t %.4f -r 1 %i -I 2 5 5 100&quot;</span>, theta <span class="sc">*</span> <span class="dv">4</span> <span class="sc">*</span> N0, .size))</span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>    <span class="fu">return</span>(ssites<span class="sc">$</span>seg_sites[[<span class="dv">1</span>]])</span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>}</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a>ssites <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">seg_sites =</span> <span class="fu">lapply</span>(ref<span class="sc">$</span><span class="fu">sizes</span>(), one_chrom))</span></code></pre></div>
<p>Using the previously created objects for molecular evolution
information and the <code>haps_ssites</code> function, I create
haplotypes from the reference genome:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>haps <span class="ot">&lt;-</span> <span class="fu">create_haplotypes</span>(ref, <span class="fu">haps_ssites</span>(ssites), sub, ins, del)</span></code></pre></div>
<p>This results in the following set of haplotypes:</p>
<pre><code>#&gt;                               &lt;&lt; haplotypes object &gt;&gt;
#&gt; # Haplotypes: 10
#&gt; # Mutations: 2,553
#&gt; 
#&gt;                           &lt;&lt; Reference genome info: &gt;&gt;
#&gt; &lt; Set of 4 chromosomes &gt;
#&gt; # Total size: 961 bp
#&gt;   name                             chromosome                             length
#&gt; 2          TCTCACGGAAAACGGGAAGTTTTTGGCC...CAAGGCTTCGACGTAGAGCCGGTGGATT       232
#&gt; 3          GCTCCGGCAGCATCGGCTTCCGTGATCA...GGACTGCGGGGGTTCTAACGGGCGTCGG       245
#&gt; 4          GAATGCTCGCATGCGAACACTGAACGTT...GAATGCCAGTAAGCTCGAGCGTATAAGG       247
#&gt; X          CCCCATTTCAGCAACGAAGTCGATCGCA...GTTCAATCACGCGAAAAAAAACACGTCA       237</code></pre>
<p>For a file of true divergences from the reference genome, the
<code>write_vcf</code> function writes the <code>haplotypes</code>
object to a VCF file:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="fu">write_vcf</span>(haps, <span class="st">&quot;haplotypes&quot;</span>)</span></code></pre></div>
<p>Lastly, I simulate 1 lane of <span class="math inline">\(2 \times
100\)</span>bp Illumina HiSeq 2500 sequencing. In this case, individuals
within a population are pooled, and the population sequences are derived
from are identified by barcodes.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="fu">illumina</span>(haps, <span class="at">out_prefix =</span> <span class="st">&quot;haps_illumina&quot;</span>, <span class="at">n_reads =</span> <span class="fl">500e6</span>, <span class="at">paired =</span> <span class="cn">TRUE</span>,</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>         <span class="at">read_length =</span> <span class="dv">100</span>, <span class="at">barcodes =</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">&quot;AACCGCGG&quot;</span>, <span class="dv">5</span>), </span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>                                         <span class="fu">rep</span>(<span class="st">&quot;GGTTATAA&quot;</span>, <span class="dv">5</span>)))</span></code></pre></div>
<p>The below example instead has each individual haplotype’s reads
output to separate FASTQ files:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="fu">illumina</span>(haps, <span class="at">out_prefix =</span> <span class="st">&quot;haps_illumina&quot;</span>, <span class="at">n_reads =</span> <span class="fl">500e6</span>, <span class="at">paired =</span> <span class="cn">TRUE</span>,</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>         <span class="at">read_length =</span> <span class="dv">100</span>, <span class="at">sep_files =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p>The <span class="math inline">\(F_{ST}\)</span> calculated from the
resulting VCF file could then be compared to output from various
programs to inform which works best in a particular case. For uncertain
population parameters (e.g., migration rates), output from multiple
calls to <code>scrm</code> varying the parameter of interest could be
input to the <code>jackalope</code> pipeline above to identify the
conditions under which one program might have an advantage over
another.</p>
</div>
<div id="constructing-a-phylogeny" class="section level2">
<h2>Constructing a phylogeny</h2>
<div id="from-one-phylogenetic-tree" class="section level3">
<h3>From one phylogenetic tree</h3>
<p>This section shows how <code>jackalope</code> can generate haplotypes
from a phylogeny, then simulate sequencing data from those haplotypes to
test phylogeny reconstruction methods. First, I simulated a random
species tree of 10 species, then scaled it to have a maximum tree depth
of <span class="math inline">\(4 N_0\)</span> generations:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>tree <span class="ot">&lt;-</span> <span class="fu">rcoal</span>(<span class="dv">10</span>)</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>tree<span class="sc">$</span>edge.length <span class="ot">&lt;-</span> <span class="dv">4</span> <span class="sc">*</span> N0 <span class="sc">*</span> tree<span class="sc">$</span>edge.length <span class="sc">/</span> <span class="fu">max</span>(<span class="fu">node.depth.edgelength</span>(tree))</span></code></pre></div>
<p>Function <code>haps_phylo</code> organizes and checks the
<code>tree</code> object, and including it with the mutation-type
information allowed me to create haplotypes based on this phylogeny:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>haps <span class="ot">&lt;-</span> <span class="fu">create_haplotypes</span>(ref, <span class="fu">haps_phylo</span>(tree), sub, ins, del)</span></code></pre></div>
<p>This results in the following <code>haplotypes</code> object:</p>
<pre><code>#&gt;                               &lt;&lt; haplotypes object &gt;&gt;
#&gt; # Haplotypes: 10
#&gt; # Mutations: 547
#&gt; 
#&gt;                           &lt;&lt; Reference genome info: &gt;&gt;
#&gt; &lt; Set of 4 chromosomes &gt;
#&gt; # Total size: 961 bp
#&gt;   name                             chromosome                             length
#&gt; 2          TCTCACGGAAAACGGGAAGTTTTTGGCC...CAAGGCTTCGACGTAGAGCCGGTGGATT       232
#&gt; 3          GCTCCGGCAGCATCGGCTTCCGTGATCA...GGACTGCGGGGGTTCTAACGGGCGTCGG       245
#&gt; 4          GAATGCTCGCATGCGAACACTGAACGTT...GAATGCCAGTAAGCTCGAGCGTATAAGG       247
#&gt; X          CCCCATTTCAGCAACGAAGTCGATCGCA...GTTCAATCACGCGAAAAAAAACACGTCA       237</code></pre>
<p>Now I can generate data for 1 flow cell of <span class="math inline">\(2 \times 250\)</span>bp sequencing on an Illumina
MiSeq v3, where <code>haplotype_barcodes</code> is a character string
that specifies the barcodes for each haplotype. I also wrote the true
phylogenetic tree to a NEWICK file.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>haplotype_barcodes <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;CTAGCTTG&quot;</span>, <span class="st">&quot;TCGATCCA&quot;</span>, <span class="st">&quot;ATACCAAG&quot;</span>, <span class="st">&quot;GCGTTGGA&quot;</span>,</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>                        <span class="st">&quot;CTTCACGG&quot;</span>, <span class="st">&quot;TCCTGTAA&quot;</span>, <span class="st">&quot;CCTCGGTA&quot;</span>, <span class="st">&quot;TTCTAACG&quot;</span>, </span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>                        <span class="st">&quot;CGCTCGTG&quot;</span>, <span class="st">&quot;TATCTACA&quot;</span>)</span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a><span class="fu">illumina</span>(haps, <span class="at">out_prefix =</span> <span class="st">&quot;phylo_tree&quot;</span>, <span class="at">seq_sys =</span> <span class="st">&quot;MSv3&quot;</span>,</span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>         <span class="at">paired =</span> <span class="cn">TRUE</span>, <span class="at">read_length =</span> <span class="dv">250</span>, <span class="at">n_reads =</span> <span class="fl">50e6</span>,</span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a>         <span class="at">barcodes =</span> haplotype_barcodes)</span>
<span id="cb21-7"><a href="#cb21-7" tabindex="-1"></a>ape<span class="sc">::</span><span class="fu">write.tree</span>(tree, <span class="st">&quot;true.tree&quot;</span>)</span></code></pre></div>
<p>The true phylogenetic tree would then be compared to the final tree
output from the program(s) the user chooses to test.</p>
</div>
<div id="from-gene-trees" class="section level3">
<h3>From gene trees</h3>
<p>Similar to the section above, the ultimate goal here is to test
phylogeny reconstruction methods. The difference in this section is that
instead of using a single, straightforward phylogeny, I use multiple
gene trees per chromosome. In the species used in these simulations,
species 1 diverged from 2 and 3 at <span class="math inline">\(t =
1.0\)</span>, where <span class="math inline">\(t\)</span> indicates
time into the past and is in units of <span class="math inline">\(4
N_0\)</span> generations. Species 2 and 3 diverged at <span class="math inline">\(t = 0.5\)</span>. I assume a recombination rate of
<span class="math inline">\(1 / (4 N_0)\)</span> recombination events
per chromosome per generation. There are 4 diploid individuals sampled
per species. I used the following code to call <code>scrm</code> to
simulate the gene trees and create the object <code>gtrees</code>. And
like the section using segregating sites, we have to wrap
<code>lapply</code> inside <code>list(trees = ...)</code> to replicate
the data structure from <code>scrm</code> for <code>jackalope</code> to
use later.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="co"># Run scrm for one chromosome size:</span></span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>one_chrom <span class="ot">&lt;-</span> <span class="cf">function</span>(.size) {</span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a>    sims <span class="ot">&lt;-</span> <span class="fu">scrm</span>(</span>
<span id="cb22-4"><a href="#cb22-4" tabindex="-1"></a>        <span class="fu">paste</span>(<span class="st">&quot;24 1&quot;</span>,</span>
<span id="cb22-5"><a href="#cb22-5" tabindex="-1"></a>              <span class="co"># Output gene trees:</span></span>
<span id="cb22-6"><a href="#cb22-6" tabindex="-1"></a>              <span class="st">&quot;-T&quot;</span>,</span>
<span id="cb22-7"><a href="#cb22-7" tabindex="-1"></a>              <span class="co"># Recombination:</span></span>
<span id="cb22-8"><a href="#cb22-8" tabindex="-1"></a>              <span class="st">&quot;-r 1&quot;</span>, .size,</span>
<span id="cb22-9"><a href="#cb22-9" tabindex="-1"></a>              <span class="co"># 3 species with no ongoing migration:</span></span>
<span id="cb22-10"><a href="#cb22-10" tabindex="-1"></a>              <span class="st">&quot;-I 3 8 8 8 0&quot;</span>,</span>
<span id="cb22-11"><a href="#cb22-11" tabindex="-1"></a>              <span class="co"># Species 2 derived from 1 at time 1.0:</span></span>
<span id="cb22-12"><a href="#cb22-12" tabindex="-1"></a>              <span class="st">&quot;-ej 1.0 2 1&quot;</span>,  </span>
<span id="cb22-13"><a href="#cb22-13" tabindex="-1"></a>              <span class="co"># Species 3 derived from 2 at time 0.5:</span></span>
<span id="cb22-14"><a href="#cb22-14" tabindex="-1"></a>              <span class="st">&quot;-ej 0.5 3 2&quot;</span></span>
<span id="cb22-15"><a href="#cb22-15" tabindex="-1"></a>        ))</span>
<span id="cb22-16"><a href="#cb22-16" tabindex="-1"></a>    trees <span class="ot">&lt;-</span> sims<span class="sc">$</span>trees[[<span class="dv">1</span>]]</span>
<span id="cb22-17"><a href="#cb22-17" tabindex="-1"></a>    <span class="co"># scrm outputs branch lengths in units of 4*N0 generations, but we want just</span></span>
<span id="cb22-18"><a href="#cb22-18" tabindex="-1"></a>    <span class="co"># generations:</span></span>
<span id="cb22-19"><a href="#cb22-19" tabindex="-1"></a>    adjust_tree <span class="ot">&lt;-</span> <span class="cf">function</span>(.p) {</span>
<span id="cb22-20"><a href="#cb22-20" tabindex="-1"></a>        <span class="co"># Read to phylo object and adjust branch lengths:</span></span>
<span id="cb22-21"><a href="#cb22-21" tabindex="-1"></a>        .tr <span class="ot">&lt;-</span> <span class="fu">read.tree</span>(<span class="at">text =</span> .p)</span>
<span id="cb22-22"><a href="#cb22-22" tabindex="-1"></a>        .tr<span class="sc">$</span>edge.length <span class="ot">&lt;-</span> .tr<span class="sc">$</span>edge.length <span class="sc">*</span> <span class="dv">4</span> <span class="sc">*</span> N0</span>
<span id="cb22-23"><a href="#cb22-23" tabindex="-1"></a>        <span class="co"># &quot;prefix&quot; from `.p` showing how large the region this gene tree refers to is</span></span>
<span id="cb22-24"><a href="#cb22-24" tabindex="-1"></a>        prefix <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="fu">strsplit</span>(.p, <span class="st">&quot;</span><span class="sc">\\</span><span class="st">]&quot;</span>)[[<span class="dv">1</span>]][<span class="dv">1</span>], <span class="st">&quot;]&quot;</span>)</span>
<span id="cb22-25"><a href="#cb22-25" tabindex="-1"></a>        <span class="co"># Put back together into NEWICK text</span></span>
<span id="cb22-26"><a href="#cb22-26" tabindex="-1"></a>        <span class="fu">return</span>(<span class="fu">paste0</span>(prefix, <span class="fu">write.tree</span>(.tr)))</span>
<span id="cb22-27"><a href="#cb22-27" tabindex="-1"></a>    }</span>
<span id="cb22-28"><a href="#cb22-28" tabindex="-1"></a>    trees <span class="ot">&lt;-</span> <span class="fu">sapply</span>(trees, adjust_tree)</span>
<span id="cb22-29"><a href="#cb22-29" tabindex="-1"></a>    <span class="fu">names</span>(trees) <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb22-30"><a href="#cb22-30" tabindex="-1"></a>    <span class="fu">return</span>(trees)</span>
<span id="cb22-31"><a href="#cb22-31" tabindex="-1"></a>}</span>
<span id="cb22-32"><a href="#cb22-32" tabindex="-1"></a><span class="co"># For all chromosomes:</span></span>
<span id="cb22-33"><a href="#cb22-33" tabindex="-1"></a>gtrees <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">trees =</span> <span class="fu">lapply</span>(ref<span class="sc">$</span><span class="fu">sizes</span>(), one_chrom))</span></code></pre></div>
<p>We can write the true gene trees using <code>write_gtrees</code> to
an <code>ms</code>-style file:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="fu">write_gtrees</span>(<span class="fu">haps_gtrees</span>(gtrees), <span class="st">&quot;gtrees&quot;</span>)</span></code></pre></div>
<p>The <code>create_haplotypes</code> function uses these gene trees to
create variant haplotypes. As for the other haplotype-creation methods,
function <code>haps_gtrees</code> checks and organizes information from
the <code>gtrees</code> object.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a>haps <span class="ot">&lt;-</span> <span class="fu">create_haplotypes</span>(ref, <span class="fu">haps_gtrees</span>(gtrees),</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a>                          sub, ins, del)</span></code></pre></div>
<p>This results in the following <code>haplotypes</code> object:</p>
<pre><code>#&gt;                               &lt;&lt; haplotypes object &gt;&gt;
#&gt; # Haplotypes: 24
#&gt; # Mutations: 2,782
#&gt; 
#&gt;                           &lt;&lt; Reference genome info: &gt;&gt;
#&gt; &lt; Set of 4 chromosomes &gt;
#&gt; # Total size: 961 bp
#&gt;   name                             chromosome                             length
#&gt; 2          TCTCACGGAAAACGGGAAGTTTTTGGCC...CAAGGCTTCGACGTAGAGCCGGTGGATT       232
#&gt; 3          GCTCCGGCAGCATCGGCTTCCGTGATCA...GGACTGCGGGGGTTCTAACGGGCGTCGG       245
#&gt; 4          GAATGCTCGCATGCGAACACTGAACGTT...GAATGCCAGTAAGCTCGAGCGTATAAGG       247
#&gt; X          CCCCATTTCAGCAACGAAGTCGATCGCA...GTTCAATCACGCGAAAAAAAACACGTCA       237</code></pre>
<p>To store mutation information by diploid sample, the
<code>write_vcf</code> function writes the <code>haplotypes</code>
object to a VCF file. It assigns every other haplotype to a new diploid
sample using a matrix for the <code>sample_matrix</code> argument:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a><span class="fu">write_vcf</span>(haps, <span class="at">out_prefix =</span> <span class="st">&quot;hap_gtrees&quot;</span>,</span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a>          <span class="at">sample_matrix =</span> <span class="fu">matrix</span>(<span class="dv">1</span><span class="sc">:</span>haps<span class="sc">$</span><span class="fu">n_haps</span>(), <span class="at">ncol =</span> <span class="dv">2</span>, <span class="at">byrow =</span> <span class="cn">TRUE</span>))</span></code></pre></div>
<p>Next I generated data for 1 flow cell of <span class="math inline">\(2 \times 250\)</span>bp sequencing on an Illumina
MiSeq v3, with barcodes in the object
<code>haplotype_barcodes</code>.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a><span class="co"># 2 of each barcode bc it&#39;s diploid</span></span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a>haplotype_barcodes <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">&quot;TCGCCTTA&quot;</span>, <span class="st">&quot;CTAGTACG&quot;</span>, <span class="st">&quot;TTCTGCCT&quot;</span>, <span class="st">&quot;GCTCAGGA&quot;</span>, <span class="st">&quot;AGGAGTCC&quot;</span>, </span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a>                            <span class="st">&quot;CATGCCTA&quot;</span>, <span class="st">&quot;GTAGAGAG&quot;</span>, <span class="st">&quot;CCTCTCTG&quot;</span>, <span class="st">&quot;AGCGTAGC&quot;</span>, <span class="st">&quot;CAGCCTCG&quot;</span>, </span>
<span id="cb27-4"><a href="#cb27-4" tabindex="-1"></a>                            <span class="st">&quot;TGCCTCTT&quot;</span>, <span class="st">&quot;TCCTCTAC&quot;</span>), <span class="at">each =</span> <span class="dv">2</span>)</span>
<span id="cb27-5"><a href="#cb27-5" tabindex="-1"></a><span class="fu">illumina</span>(haps, <span class="at">out_prefix =</span> <span class="st">&quot;phylo_gtrees&quot;</span>, <span class="at">seq_sys =</span> <span class="st">&quot;MSv3&quot;</span>,</span>
<span id="cb27-6"><a href="#cb27-6" tabindex="-1"></a>         <span class="at">read_length =</span> <span class="dv">250</span>, <span class="at">n_reads =</span> <span class="fl">50e6</span>, <span class="at">paired =</span> <span class="cn">TRUE</span>, </span>
<span id="cb27-7"><a href="#cb27-7" tabindex="-1"></a>         <span class="at">barcodes =</span> haplotype_barcodes)</span></code></pre></div>
<p>Topologies of the gene trees would then be compared to final
phylogenies output from software the user is interested in testing.
Varying recombination rates or adding gene flow after separation of
species would be natural extensions of these simulations.</p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
